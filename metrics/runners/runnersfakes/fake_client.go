// Code generated by counterfeiter. DO NOT EDIT.
package runnersfakes

import (
	"context"
	"sync"
	"time"

	"github.com/3xcellent/github-metrics/metrics/runners"
	"github.com/3xcellent/github-metrics/models"
)

type FakeClient struct {
	GetIssueStub        func(context.Context, string, string, int) (models.Issue, error)
	getIssueMutex       sync.RWMutex
	getIssueArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}
	getIssueReturns struct {
		result1 models.Issue
		result2 error
	}
	getIssueReturnsOnCall map[int]struct {
		result1 models.Issue
		result2 error
	}
	GetIssueEventsStub        func(context.Context, string, string, int) (models.IssueEvents, error)
	getIssueEventsMutex       sync.RWMutex
	getIssueEventsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}
	getIssueEventsReturns struct {
		result1 models.IssueEvents
		result2 error
	}
	getIssueEventsReturnsOnCall map[int]struct {
		result1 models.IssueEvents
		result2 error
	}
	GetIssuesStub        func(context.Context, string, []string, time.Time, time.Time) (models.Issues, error)
	getIssuesMutex       sync.RWMutex
	getIssuesArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 time.Time
		arg5 time.Time
	}
	getIssuesReturns struct {
		result1 models.Issues
		result2 error
	}
	getIssuesReturnsOnCall map[int]struct {
		result1 models.Issues
		result2 error
	}
	GetProjectStub        func(context.Context, int64) (models.Project, error)
	getProjectMutex       sync.RWMutex
	getProjectArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	getProjectReturns struct {
		result1 models.Project
		result2 error
	}
	getProjectReturnsOnCall map[int]struct {
		result1 models.Project
		result2 error
	}
	GetProjectColumnsStub        func(context.Context, int64) (models.ProjectColumns, error)
	getProjectColumnsMutex       sync.RWMutex
	getProjectColumnsArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	getProjectColumnsReturns struct {
		result1 models.ProjectColumns
		result2 error
	}
	getProjectColumnsReturnsOnCall map[int]struct {
		result1 models.ProjectColumns
		result2 error
	}
	GetProjectsStub        func(context.Context, string) (models.Projects, error)
	getProjectsMutex       sync.RWMutex
	getProjectsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getProjectsReturns struct {
		result1 models.Projects
		result2 error
	}
	getProjectsReturnsOnCall map[int]struct {
		result1 models.Projects
		result2 error
	}
	GetPullRequestsStub        func(context.Context, string, string) (models.PullRequests, error)
	getPullRequestsMutex       sync.RWMutex
	getPullRequestsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getPullRequestsReturns struct {
		result1 models.PullRequests
		result2 error
	}
	getPullRequestsReturnsOnCall map[int]struct {
		result1 models.PullRequests
		result2 error
	}
	GetReposFromProjectColumnStub        func(context.Context, int64) (models.Repositories, error)
	getReposFromProjectColumnMutex       sync.RWMutex
	getReposFromProjectColumnArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	getReposFromProjectColumnReturns struct {
		result1 models.Repositories
		result2 error
	}
	getReposFromProjectColumnReturnsOnCall map[int]struct {
		result1 models.Repositories
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) GetIssue(arg1 context.Context, arg2 string, arg3 string, arg4 int) (models.Issue, error) {
	fake.getIssueMutex.Lock()
	ret, specificReturn := fake.getIssueReturnsOnCall[len(fake.getIssueArgsForCall)]
	fake.getIssueArgsForCall = append(fake.getIssueArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetIssueStub
	fakeReturns := fake.getIssueReturns
	fake.recordInvocation("GetIssue", []interface{}{arg1, arg2, arg3, arg4})
	fake.getIssueMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetIssueCallCount() int {
	fake.getIssueMutex.RLock()
	defer fake.getIssueMutex.RUnlock()
	return len(fake.getIssueArgsForCall)
}

func (fake *FakeClient) GetIssueCalls(stub func(context.Context, string, string, int) (models.Issue, error)) {
	fake.getIssueMutex.Lock()
	defer fake.getIssueMutex.Unlock()
	fake.GetIssueStub = stub
}

func (fake *FakeClient) GetIssueArgsForCall(i int) (context.Context, string, string, int) {
	fake.getIssueMutex.RLock()
	defer fake.getIssueMutex.RUnlock()
	argsForCall := fake.getIssueArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) GetIssueReturns(result1 models.Issue, result2 error) {
	fake.getIssueMutex.Lock()
	defer fake.getIssueMutex.Unlock()
	fake.GetIssueStub = nil
	fake.getIssueReturns = struct {
		result1 models.Issue
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetIssueReturnsOnCall(i int, result1 models.Issue, result2 error) {
	fake.getIssueMutex.Lock()
	defer fake.getIssueMutex.Unlock()
	fake.GetIssueStub = nil
	if fake.getIssueReturnsOnCall == nil {
		fake.getIssueReturnsOnCall = make(map[int]struct {
			result1 models.Issue
			result2 error
		})
	}
	fake.getIssueReturnsOnCall[i] = struct {
		result1 models.Issue
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetIssueEvents(arg1 context.Context, arg2 string, arg3 string, arg4 int) (models.IssueEvents, error) {
	fake.getIssueEventsMutex.Lock()
	ret, specificReturn := fake.getIssueEventsReturnsOnCall[len(fake.getIssueEventsArgsForCall)]
	fake.getIssueEventsArgsForCall = append(fake.getIssueEventsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetIssueEventsStub
	fakeReturns := fake.getIssueEventsReturns
	fake.recordInvocation("GetIssueEvents", []interface{}{arg1, arg2, arg3, arg4})
	fake.getIssueEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetIssueEventsCallCount() int {
	fake.getIssueEventsMutex.RLock()
	defer fake.getIssueEventsMutex.RUnlock()
	return len(fake.getIssueEventsArgsForCall)
}

func (fake *FakeClient) GetIssueEventsCalls(stub func(context.Context, string, string, int) (models.IssueEvents, error)) {
	fake.getIssueEventsMutex.Lock()
	defer fake.getIssueEventsMutex.Unlock()
	fake.GetIssueEventsStub = stub
}

func (fake *FakeClient) GetIssueEventsArgsForCall(i int) (context.Context, string, string, int) {
	fake.getIssueEventsMutex.RLock()
	defer fake.getIssueEventsMutex.RUnlock()
	argsForCall := fake.getIssueEventsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) GetIssueEventsReturns(result1 models.IssueEvents, result2 error) {
	fake.getIssueEventsMutex.Lock()
	defer fake.getIssueEventsMutex.Unlock()
	fake.GetIssueEventsStub = nil
	fake.getIssueEventsReturns = struct {
		result1 models.IssueEvents
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetIssueEventsReturnsOnCall(i int, result1 models.IssueEvents, result2 error) {
	fake.getIssueEventsMutex.Lock()
	defer fake.getIssueEventsMutex.Unlock()
	fake.GetIssueEventsStub = nil
	if fake.getIssueEventsReturnsOnCall == nil {
		fake.getIssueEventsReturnsOnCall = make(map[int]struct {
			result1 models.IssueEvents
			result2 error
		})
	}
	fake.getIssueEventsReturnsOnCall[i] = struct {
		result1 models.IssueEvents
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetIssues(arg1 context.Context, arg2 string, arg3 []string, arg4 time.Time, arg5 time.Time) (models.Issues, error) {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.getIssuesMutex.Lock()
	ret, specificReturn := fake.getIssuesReturnsOnCall[len(fake.getIssuesArgsForCall)]
	fake.getIssuesArgsForCall = append(fake.getIssuesArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
		arg4 time.Time
		arg5 time.Time
	}{arg1, arg2, arg3Copy, arg4, arg5})
	stub := fake.GetIssuesStub
	fakeReturns := fake.getIssuesReturns
	fake.recordInvocation("GetIssues", []interface{}{arg1, arg2, arg3Copy, arg4, arg5})
	fake.getIssuesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetIssuesCallCount() int {
	fake.getIssuesMutex.RLock()
	defer fake.getIssuesMutex.RUnlock()
	return len(fake.getIssuesArgsForCall)
}

func (fake *FakeClient) GetIssuesCalls(stub func(context.Context, string, []string, time.Time, time.Time) (models.Issues, error)) {
	fake.getIssuesMutex.Lock()
	defer fake.getIssuesMutex.Unlock()
	fake.GetIssuesStub = stub
}

func (fake *FakeClient) GetIssuesArgsForCall(i int) (context.Context, string, []string, time.Time, time.Time) {
	fake.getIssuesMutex.RLock()
	defer fake.getIssuesMutex.RUnlock()
	argsForCall := fake.getIssuesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClient) GetIssuesReturns(result1 models.Issues, result2 error) {
	fake.getIssuesMutex.Lock()
	defer fake.getIssuesMutex.Unlock()
	fake.GetIssuesStub = nil
	fake.getIssuesReturns = struct {
		result1 models.Issues
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetIssuesReturnsOnCall(i int, result1 models.Issues, result2 error) {
	fake.getIssuesMutex.Lock()
	defer fake.getIssuesMutex.Unlock()
	fake.GetIssuesStub = nil
	if fake.getIssuesReturnsOnCall == nil {
		fake.getIssuesReturnsOnCall = make(map[int]struct {
			result1 models.Issues
			result2 error
		})
	}
	fake.getIssuesReturnsOnCall[i] = struct {
		result1 models.Issues
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetProject(arg1 context.Context, arg2 int64) (models.Project, error) {
	fake.getProjectMutex.Lock()
	ret, specificReturn := fake.getProjectReturnsOnCall[len(fake.getProjectArgsForCall)]
	fake.getProjectArgsForCall = append(fake.getProjectArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.GetProjectStub
	fakeReturns := fake.getProjectReturns
	fake.recordInvocation("GetProject", []interface{}{arg1, arg2})
	fake.getProjectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetProjectCallCount() int {
	fake.getProjectMutex.RLock()
	defer fake.getProjectMutex.RUnlock()
	return len(fake.getProjectArgsForCall)
}

func (fake *FakeClient) GetProjectCalls(stub func(context.Context, int64) (models.Project, error)) {
	fake.getProjectMutex.Lock()
	defer fake.getProjectMutex.Unlock()
	fake.GetProjectStub = stub
}

func (fake *FakeClient) GetProjectArgsForCall(i int) (context.Context, int64) {
	fake.getProjectMutex.RLock()
	defer fake.getProjectMutex.RUnlock()
	argsForCall := fake.getProjectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetProjectReturns(result1 models.Project, result2 error) {
	fake.getProjectMutex.Lock()
	defer fake.getProjectMutex.Unlock()
	fake.GetProjectStub = nil
	fake.getProjectReturns = struct {
		result1 models.Project
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetProjectReturnsOnCall(i int, result1 models.Project, result2 error) {
	fake.getProjectMutex.Lock()
	defer fake.getProjectMutex.Unlock()
	fake.GetProjectStub = nil
	if fake.getProjectReturnsOnCall == nil {
		fake.getProjectReturnsOnCall = make(map[int]struct {
			result1 models.Project
			result2 error
		})
	}
	fake.getProjectReturnsOnCall[i] = struct {
		result1 models.Project
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetProjectColumns(arg1 context.Context, arg2 int64) (models.ProjectColumns, error) {
	fake.getProjectColumnsMutex.Lock()
	ret, specificReturn := fake.getProjectColumnsReturnsOnCall[len(fake.getProjectColumnsArgsForCall)]
	fake.getProjectColumnsArgsForCall = append(fake.getProjectColumnsArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.GetProjectColumnsStub
	fakeReturns := fake.getProjectColumnsReturns
	fake.recordInvocation("GetProjectColumns", []interface{}{arg1, arg2})
	fake.getProjectColumnsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetProjectColumnsCallCount() int {
	fake.getProjectColumnsMutex.RLock()
	defer fake.getProjectColumnsMutex.RUnlock()
	return len(fake.getProjectColumnsArgsForCall)
}

func (fake *FakeClient) GetProjectColumnsCalls(stub func(context.Context, int64) (models.ProjectColumns, error)) {
	fake.getProjectColumnsMutex.Lock()
	defer fake.getProjectColumnsMutex.Unlock()
	fake.GetProjectColumnsStub = stub
}

func (fake *FakeClient) GetProjectColumnsArgsForCall(i int) (context.Context, int64) {
	fake.getProjectColumnsMutex.RLock()
	defer fake.getProjectColumnsMutex.RUnlock()
	argsForCall := fake.getProjectColumnsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetProjectColumnsReturns(result1 models.ProjectColumns, result2 error) {
	fake.getProjectColumnsMutex.Lock()
	defer fake.getProjectColumnsMutex.Unlock()
	fake.GetProjectColumnsStub = nil
	fake.getProjectColumnsReturns = struct {
		result1 models.ProjectColumns
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetProjectColumnsReturnsOnCall(i int, result1 models.ProjectColumns, result2 error) {
	fake.getProjectColumnsMutex.Lock()
	defer fake.getProjectColumnsMutex.Unlock()
	fake.GetProjectColumnsStub = nil
	if fake.getProjectColumnsReturnsOnCall == nil {
		fake.getProjectColumnsReturnsOnCall = make(map[int]struct {
			result1 models.ProjectColumns
			result2 error
		})
	}
	fake.getProjectColumnsReturnsOnCall[i] = struct {
		result1 models.ProjectColumns
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetProjects(arg1 context.Context, arg2 string) (models.Projects, error) {
	fake.getProjectsMutex.Lock()
	ret, specificReturn := fake.getProjectsReturnsOnCall[len(fake.getProjectsArgsForCall)]
	fake.getProjectsArgsForCall = append(fake.getProjectsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetProjectsStub
	fakeReturns := fake.getProjectsReturns
	fake.recordInvocation("GetProjects", []interface{}{arg1, arg2})
	fake.getProjectsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetProjectsCallCount() int {
	fake.getProjectsMutex.RLock()
	defer fake.getProjectsMutex.RUnlock()
	return len(fake.getProjectsArgsForCall)
}

func (fake *FakeClient) GetProjectsCalls(stub func(context.Context, string) (models.Projects, error)) {
	fake.getProjectsMutex.Lock()
	defer fake.getProjectsMutex.Unlock()
	fake.GetProjectsStub = stub
}

func (fake *FakeClient) GetProjectsArgsForCall(i int) (context.Context, string) {
	fake.getProjectsMutex.RLock()
	defer fake.getProjectsMutex.RUnlock()
	argsForCall := fake.getProjectsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetProjectsReturns(result1 models.Projects, result2 error) {
	fake.getProjectsMutex.Lock()
	defer fake.getProjectsMutex.Unlock()
	fake.GetProjectsStub = nil
	fake.getProjectsReturns = struct {
		result1 models.Projects
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetProjectsReturnsOnCall(i int, result1 models.Projects, result2 error) {
	fake.getProjectsMutex.Lock()
	defer fake.getProjectsMutex.Unlock()
	fake.GetProjectsStub = nil
	if fake.getProjectsReturnsOnCall == nil {
		fake.getProjectsReturnsOnCall = make(map[int]struct {
			result1 models.Projects
			result2 error
		})
	}
	fake.getProjectsReturnsOnCall[i] = struct {
		result1 models.Projects
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetPullRequests(arg1 context.Context, arg2 string, arg3 string) (models.PullRequests, error) {
	fake.getPullRequestsMutex.Lock()
	ret, specificReturn := fake.getPullRequestsReturnsOnCall[len(fake.getPullRequestsArgsForCall)]
	fake.getPullRequestsArgsForCall = append(fake.getPullRequestsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetPullRequestsStub
	fakeReturns := fake.getPullRequestsReturns
	fake.recordInvocation("GetPullRequests", []interface{}{arg1, arg2, arg3})
	fake.getPullRequestsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetPullRequestsCallCount() int {
	fake.getPullRequestsMutex.RLock()
	defer fake.getPullRequestsMutex.RUnlock()
	return len(fake.getPullRequestsArgsForCall)
}

func (fake *FakeClient) GetPullRequestsCalls(stub func(context.Context, string, string) (models.PullRequests, error)) {
	fake.getPullRequestsMutex.Lock()
	defer fake.getPullRequestsMutex.Unlock()
	fake.GetPullRequestsStub = stub
}

func (fake *FakeClient) GetPullRequestsArgsForCall(i int) (context.Context, string, string) {
	fake.getPullRequestsMutex.RLock()
	defer fake.getPullRequestsMutex.RUnlock()
	argsForCall := fake.getPullRequestsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) GetPullRequestsReturns(result1 models.PullRequests, result2 error) {
	fake.getPullRequestsMutex.Lock()
	defer fake.getPullRequestsMutex.Unlock()
	fake.GetPullRequestsStub = nil
	fake.getPullRequestsReturns = struct {
		result1 models.PullRequests
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetPullRequestsReturnsOnCall(i int, result1 models.PullRequests, result2 error) {
	fake.getPullRequestsMutex.Lock()
	defer fake.getPullRequestsMutex.Unlock()
	fake.GetPullRequestsStub = nil
	if fake.getPullRequestsReturnsOnCall == nil {
		fake.getPullRequestsReturnsOnCall = make(map[int]struct {
			result1 models.PullRequests
			result2 error
		})
	}
	fake.getPullRequestsReturnsOnCall[i] = struct {
		result1 models.PullRequests
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetReposFromProjectColumn(arg1 context.Context, arg2 int64) (models.Repositories, error) {
	fake.getReposFromProjectColumnMutex.Lock()
	ret, specificReturn := fake.getReposFromProjectColumnReturnsOnCall[len(fake.getReposFromProjectColumnArgsForCall)]
	fake.getReposFromProjectColumnArgsForCall = append(fake.getReposFromProjectColumnArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	stub := fake.GetReposFromProjectColumnStub
	fakeReturns := fake.getReposFromProjectColumnReturns
	fake.recordInvocation("GetReposFromProjectColumn", []interface{}{arg1, arg2})
	fake.getReposFromProjectColumnMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetReposFromProjectColumnCallCount() int {
	fake.getReposFromProjectColumnMutex.RLock()
	defer fake.getReposFromProjectColumnMutex.RUnlock()
	return len(fake.getReposFromProjectColumnArgsForCall)
}

func (fake *FakeClient) GetReposFromProjectColumnCalls(stub func(context.Context, int64) (models.Repositories, error)) {
	fake.getReposFromProjectColumnMutex.Lock()
	defer fake.getReposFromProjectColumnMutex.Unlock()
	fake.GetReposFromProjectColumnStub = stub
}

func (fake *FakeClient) GetReposFromProjectColumnArgsForCall(i int) (context.Context, int64) {
	fake.getReposFromProjectColumnMutex.RLock()
	defer fake.getReposFromProjectColumnMutex.RUnlock()
	argsForCall := fake.getReposFromProjectColumnArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetReposFromProjectColumnReturns(result1 models.Repositories, result2 error) {
	fake.getReposFromProjectColumnMutex.Lock()
	defer fake.getReposFromProjectColumnMutex.Unlock()
	fake.GetReposFromProjectColumnStub = nil
	fake.getReposFromProjectColumnReturns = struct {
		result1 models.Repositories
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetReposFromProjectColumnReturnsOnCall(i int, result1 models.Repositories, result2 error) {
	fake.getReposFromProjectColumnMutex.Lock()
	defer fake.getReposFromProjectColumnMutex.Unlock()
	fake.GetReposFromProjectColumnStub = nil
	if fake.getReposFromProjectColumnReturnsOnCall == nil {
		fake.getReposFromProjectColumnReturnsOnCall = make(map[int]struct {
			result1 models.Repositories
			result2 error
		})
	}
	fake.getReposFromProjectColumnReturnsOnCall[i] = struct {
		result1 models.Repositories
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getIssueMutex.RLock()
	defer fake.getIssueMutex.RUnlock()
	fake.getIssueEventsMutex.RLock()
	defer fake.getIssueEventsMutex.RUnlock()
	fake.getIssuesMutex.RLock()
	defer fake.getIssuesMutex.RUnlock()
	fake.getProjectMutex.RLock()
	defer fake.getProjectMutex.RUnlock()
	fake.getProjectColumnsMutex.RLock()
	defer fake.getProjectColumnsMutex.RUnlock()
	fake.getProjectsMutex.RLock()
	defer fake.getProjectsMutex.RUnlock()
	fake.getPullRequestsMutex.RLock()
	defer fake.getPullRequestsMutex.RUnlock()
	fake.getReposFromProjectColumnMutex.RLock()
	defer fake.getReposFromProjectColumnMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ runners.Client = new(FakeClient)
